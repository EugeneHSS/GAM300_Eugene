#version 450 core

struct Particle {
    //transform params
    vec3 Size;//xyz scale of the particle
    vec3 Rotation;
    vec3 CurrentPosition;// constant transform position of the entity, position of particle is an offset from here based on velocity and acceleration
    
    //movement params
    vec3 Velocity;
    vec3 Acceleration;
    float Age;//how long has the particle been active
    
    //aesthetics params
    vec3 Color;//rgb color of the particle
    bool Active;//is the particle active
};

struct ParticleEmitter{
    float min_Life, max_Life;
    vec3 min_Spawnoffset, max_Spawnoffset;
    vec3 min_Velocity, max_Velocity;
    vec3 min_Acceleration, max_Acceleration;
    vec3 min_Size, max_Size;
    vec3 Position;
    vec4 Color;
};
float seed(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233)))* 43758.5453);
}

float rand(float min, float max){
    return mix(min, max, seed(vec2(3.8,5.0)+ gl_GlobalInvocationID.xy));
}

vec3 randvec3(vec3 min, vec3 max){
    return vec3(rand(min.x,max.x),rand(min.y,max.y),rand(min.z,max.z));
}

//writing the position of the particle out into a list to vertex buffer
layout (std430, binding = 31) buffer ParticleBuffer {
    Particle List[];
}v_ParticleOut;

//buffer access with particle shader?
layout (std430, binding = 32) coherent restrict buffer FreelistBuffer {
    int count;
    int indices[];
}v_Freelist;

layout (set = 0, binding = 33 ) buffer EmitterThingy{
    int particleamount;
    ParticleEmitter Emitter;
}EmitterStuff;

void MakeParticle(out Particle newparticle){
    //constant spawn point from emitter location
    newparticle.Age =           rand(EmitterStuff.Emitter.min_Life, EmitterStuff.Emitter.max_Life);
    newparticle.Velocity =      randvec3(EmitterStuff.Emitter.min_Velocity, EmitterStuff.Emitter.max_Velocity);
    newparticle.Acceleration =  randvec3(EmitterStuff.Emitter.min_Acceleration, EmitterStuff.Emitter.max_Acceleration);
    newparticle.Size =          randvec3(EmitterStuff.Emitter.min_Size, EmitterStuff.Emitter.max_Size);
    newparticle.CurrentPosition = EmitterStuff.Emitter.Position + randvec3(EmitterStuff.Emitter.min_Spawnoffset, EmitterStuff.Emitter.max_Spawnoffset);

    newparticle.Rotation = vec3(0.0,0.0,0.0);
    newparticle.Color = EmitterStuff.Emitter.Color.xyz;
    newparticle.Active = true;
}

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

void main(){
    uint index = gl_GlobalInvocationID.x;

    if (index >= EmitterStuff.particleamount)
        return;
    
    int freelistindex = atomicAdd(v_Freelist.count, -1) -1;
    //if there are no free particles, return
    if (freelistindex < 0){
        atomicAdd(v_Freelist.count, 1);
        return;
    }

    //get the index of the free particle
    int particleindex = v_Freelist.indices[freelistindex];
    //create a new particle
    MakeParticle(v_ParticleOut.List[particleindex]);
}