#version 450 core

struct Particle {
    //transform params
    vec3 Size;//xyz scale of the particle
    vec3 Rotation;
    vec3 CurrentPosition;// constant transform position of the entity, position of particle is an offset from here based on velocity and acceleration
    
    //movement params
    vec3 Velocity;
    vec3 Acceleration;
    float Age;//how long has the particle been active
    
    //aesthetics params
    vec3 Color;//rgb color of the particle
    bool Active;//is the particle active
};

layout (std430, binding = 31) buffer Particles {
    Particle List[];
}v_Particles;

layout (std430, binding = 32) buffer Freelist{
    int count;
    uint indices[];
}v_Freelist;

layout (std430, binding = 34) writeonly buffer TransformMatrix{
    mat4 List[];
}v_TransformMatrix;

layout(set = 0, binding = 35) buffer TimeBlock {
    float DeltaTime;
}Time;

mat4 GenerateTransform(vec3 Scale, vec3 Rotate, vec3 Translate){
    mat4 Scalemat = mat4(
        Scale.x, 0.0, 0.0, 0.0,
        0.0, Scale.y, 0.0, 0.0,
        0.0, 0.0, Scale.z, 0.0,
        0.0, 0.0, 0.0, 1.0);
    
    mat4 rotationX = mat4(
        1.0, 0.0, 0.0, 0.0,
        0.0, cos(Rotate.x), -sin(Rotate.x), 0.0,
        0.0, sin(Rotate.x), cos(Rotate.x), 0.0,
        0.0, 0.0, 0.0, 1.0
    );

    mat4 rotationY= mat4(
        cos(Rotate.y), 0.0, sin(Rotate.y), 0.0,
        0.0, 1.0, 0.0, 0.0,
        -sin(Rotate.y), 0.0, cos(Rotate.y), 0.0,
        0.0, 0.0, 0.0, 1.0
    );

    mat4 rotationZ = mat4(
        cos(Rotate.z), -sin(Rotate.z), 0.0, 0.0,
        sin(Rotate.z), cos(Rotate.z), 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0
    );

    mat4 Rotmat = rotationZ * rotationY * rotationX;

    mat4 Translatemat = mat4(
        1.0, 0.0, 0.0, 0.0,
        0.0, 1.0, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        Translate.x, Translate.y, Translate.z, 1.0
    );

    mat4 Xform = Translatemat* Rotmat* Scalemat;
    return Xform;
}

void ComputeParticle(inout Particle p, int index){
    if (p.Age > 0.0){
        p.Age -= Time.DeltaTime;
        p.Velocity += p.Acceleration * Time.DeltaTime;
        p.CurrentPosition += p.Velocity * Time.DeltaTime;

        if (p.Age <= 0.0){
            p.Active = false;
            v_Freelist.indices[atomicAdd(v_Freelist.count,1)] = index;
        }
    }
}


layout(local_size_x =128, local_size_y = 1, local_size_z = 1) in;

void main(){
    uint index = gl_GlobalInvocationID.x;
    if (index >= v_Particles.List.length()){
        return;
    }

    //ComputeParticle(v_Particles.List[index], index);
    Particle currentparticle = v_Particles.List[index];
    if (currentparticle.Age > 0.){
        currentparticle.Age -= Time.DeltaTime;
        currentparticle.Velocity += currentparticle.Acceleration * Time.DeltaTime;
        currentparticle.CurrentPosition += currentparticle.Velocity * Time.DeltaTime;
        if (currentparticle.Age <= 0.0){
            currentparticle.Active = false;
            v_Freelist.indices[atomicAdd(v_Freelist.count,1)] = index;
        }
    }

    v_TransformMatrix.List[index] = GenerateTransform(v_Particles.List[index].Size, v_Particles.List[index].Rotation, v_Particles.List[index].CurrentPosition);
}